<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>縦書き脚本エディタ</title>
  <style>
    :root {
      --bg: #f0f0f0;
      --page: #ffffff;
      --frame: #909090;
      --text: #333333;
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: "游明朝", "Yu Mincho", "MS Mincho", serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap {
      height: 100%;
      display: grid;
      place-items: center;
    }
    .page {
      background: var(--page);
      border: 1px solid var(--frame);
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
      position: relative;
      overflow: hidden;
    }
    .content {
      position: absolute;
      display: flex;
      flex-direction: row-reverse;
      align-items: flex-start;
      background-image: repeating-linear-gradient(
        to left,
        rgba(0, 0, 0, 0.08) 0px,
        rgba(0, 0, 0, 0.08) 1px,
        transparent 1px,
        transparent var(--line-advance)
      );
      background-size: var(--line-advance) 100%;
      background-position: right top;
    }
    .record {
      position: relative;
      display: block;
      flex: 0 0 auto;
    }
    .role,
    .body {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      line-height: var(--line-advance);
      font-size: var(--font-size);
      font-family: var(--font-family);
      color: var(--text);
    }
    .role {
      white-space: pre;
    }
    .body {
      white-space: pre-wrap;
      word-break: break-all;
      line-break: strict;
      box-sizing: border-box;
      padding-top: var(--role-height);
      min-width: var(--line-advance);
    }
    .role[contenteditable],
    .body[contenteditable] {
      outline: none;
    }
    .tcy {
      text-combine-upright: all;
    }
    .status {
      font-size: 14px;
      letter-spacing: 0.08em;
      color: #666666;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="status" id="status">WebView2 の準備中です</div>
  </div>
  <script>
    const status = document.getElementById('status');
    const wrap = document.querySelector('.wrap');
    let currentDocument = null;
    let lastSettings = null;
    let pendingFocus = null;
    let layoutState = null;
    let layoutUpdateHandle = null;
    const layoutUpdateQueue = new Set();

    function mmToPx(mm) {
      return mm / 25.4 * 96;
    }

    const verticalGlyphMap = new Map([
      ['、', '\uFE11'],
      ['。', '\uFE12'],
      ['，', '\uFE10'],
      ['：', '\uFE13'],
      ['；', '\uFE14'],
      ['！', '\uFE15'],
      ['？', '\uFE16'],
      ['…', '\uFE19'],
      ['（', '\uFE35'],
      ['）', '\uFE36'],
      ['｛', '\uFE37'],
      ['｝', '\uFE38'],
      ['〔', '\uFE39'],
      ['〕', '\uFE3A'],
      ['【', '\uFE3B'],
      ['】', '\uFE3C'],
      ['〈', '\uFE3F'],
      ['〉', '\uFE40'],
      ['《', '\uFE3D'],
      ['》', '\uFE3E'],
      ['「', '\uFE41'],
      ['」', '\uFE42'],
      ['『', '\uFE43'],
      ['』', '\uFE44'],
      ['［', '\uFE47'],
      ['］', '\uFE48'],
    ]);
    const reverseVerticalGlyphMap = new Map(Array.from(verticalGlyphMap.entries()).map(([key, value]) => [value, key]));

    function mapVerticalGlyph(ch) {
      return verticalGlyphMap.get(ch) || ch;
    }

    function mapHorizontalGlyph(ch) {
      return reverseVerticalGlyphMap.get(ch) || ch;
    }

    function isAsciiAlnum(ch) {
      return /[0-9A-Za-z]/.test(ch);
    }

    function tokenizeText(text) {
      const tokens = [];
      let index = 0;
      while (index < text.length) {
        const ch = text[index];
        if (ch === '\r') {
          index += 1;
          continue;
        }
        if (ch === '\n') {
          tokens.push({ type: 'newline' });
          index += 1;
          continue;
        }
        if (isAsciiAlnum(ch)) {
          let run = ch;
          index += 1;
          while (index < text.length && isAsciiAlnum(text[index]) && run.length < 4) {
            run += text[index];
            index += 1;
          }
          if (run.length >= 2) {
            tokens.push({ type: 'tcy', text: run });
          } else {
            tokens.push({ type: 'text', text: mapVerticalGlyph(run) });
          }
          continue;
        }
        tokens.push({ type: 'text', text: mapVerticalGlyph(ch) });
        index += 1;
      }
      return tokens;
    }

    function takeTokens(tokens, maxSlots) {
      const result = [];
      let usedSlots = 0;
      for (const token of tokens) {
        if (token.type === 'newline') {
          break;
        }
        if (usedSlots >= maxSlots) {
          break;
        }
        result.push(token);
        usedSlots += 1;
      }
      return result;
    }

    function scheduleLayoutUpdate(recordIndex) {
      layoutUpdateQueue.add(recordIndex);
      if (layoutUpdateHandle) {
        return;
      }
      layoutUpdateHandle = requestAnimationFrame(() => {
        layoutUpdateHandle = null;
        for (const index of layoutUpdateQueue) {
          const recordElement = getRecordElement(index);
          updateRecordWidth(recordElement);
        }
        layoutUpdateQueue.clear();
      });
    }

    function updateRecordWidth(recordElement) {
      if (!recordElement || !layoutState) {
        return;
      }
      const bodyElement = getBodyElement(recordElement);
      if (!bodyElement) {
        return;
      }
      const measuredWidth = Math.ceil(bodyElement.scrollWidth);
      const width = Math.max(layoutState.lineAdvance, measuredWidth);
      recordElement.style.width = `${width}px`;
      bodyElement.style.width = `${width}px`;
    }

    function appendTokens(container, tokens) {
      container.textContent = '';
      for (const token of tokens) {
        if (token.type === 'newline') {
          container.appendChild(document.createElement('br'));
          const placeholder = document.createElement('span');
          placeholder.className = 'line-placeholder';
          placeholder.textContent = '\u200B';
          container.appendChild(placeholder);
          continue;
        }
        const span = document.createElement('span');
        if (token.type === 'tcy') {
          span.className = 'tcy';
        }
        span.textContent = token.text;
        container.appendChild(span);
      }
    }

    function extractText(node) {
      let text = '';
      function appendLineBreak() {
        text += '\n';
      }
      function walk(current) {
        if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          Array.from(current.childNodes).forEach(walk);
          return;
        }
        if (current.nodeType === Node.TEXT_NODE) {
          text += current.nodeValue || '';
          return;
        }
        if (current.nodeType !== Node.ELEMENT_NODE) {
          return;
        }
        const tag = current.tagName;
        if (tag === 'BR') {
          appendLineBreak();
          return;
        }
        if (tag === 'DIV' || tag === 'P') {
          Array.from(current.childNodes).forEach(walk);
          appendLineBreak();
          return;
        }
        Array.from(current.childNodes).forEach(walk);
      }
      walk(node);
      return text;
    }

    function normalizeText(text) {
      return text.replace(/\r/g, '').replace(/[\u200B\u00A0\uFEFF\u2060]/g, '');
    }

    function normalizeTextFromElement(element) {
      const raw = normalizeText(extractText(element));
      let result = '';
      for (const ch of raw) {
        result += mapHorizontalGlyph(ch);
      }
      return result;
    }

    function getRecordElement(recordIndex) {
      return wrap.querySelector(`.record[data-record-index=\"${recordIndex}\"]`);
    }

    function getRoleElement(recordElement) {
      return recordElement?.querySelector('.role[data-field="roleName"]') || null;
    }

    function getBodyElement(recordElement) {
      return recordElement?.querySelector('.body[data-field="body"]') || null;
    }

    function getTextAndCaret(element) {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        return { text: normalizeText(extractText(element)), caret: 0 };
      }
      const range = selection.getRangeAt(0);
      const preRange = range.cloneRange();
      preRange.selectNodeContents(element);
      preRange.setEnd(range.endContainer, range.endOffset);
      const fullText = normalizeText(extractText(element));
      const caretText = normalizeText(extractText(preRange.cloneContents()));
      return { text: fullText, caret: caretText.length };
    }

    function isCurrentLineEmpty(element) {
      const info = getTextAndCaret(element);
      const lineStart = info.text.lastIndexOf('\n', Math.max(0, info.caret - 1)) + 1;
      const lineEndCandidate = info.text.indexOf('\n', info.caret);
      const lineEnd = lineEndCandidate === -1 ? info.text.length : lineEndCandidate;
      const lineText = info.text.slice(lineStart, lineEnd).trim();
      return lineText.length === 0;
    }

    function focusElement(element, atStart = false) {
      if (!element) {
        return;
      }
      element.focus();
      const range = document.createRange();
      range.selectNodeContents(element);
      range.collapse(atStart);
      const selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    function focusRecord(recordIndex, field, atStart = false) {
      const recordElement = getRecordElement(recordIndex);
      if (!recordElement) {
        return false;
      }
      if (field === 'roleName') {
        focusElement(getRoleElement(recordElement), atStart);
      } else {
        focusElement(getBodyElement(recordElement), atStart);
      }
      return true;
    }

    function postMessage(message) {
      if (window.chrome && window.chrome.webview) {
        window.chrome.webview.postMessage(message);
      }
    }

    function insertTextAtSelection(text) {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        return;
      }
      const range = selection.getRangeAt(0);
      range.deleteContents();
      const node = document.createTextNode(text);
      range.insertNode(node);
      range.setStartAfter(node);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function insertLineBreakAtSelection() {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        return;
      }
      const range = selection.getRangeAt(0);
      range.deleteContents();
      const br = document.createElement('br');
      const placeholder = document.createElement('span');
      placeholder.className = 'line-placeholder';
      placeholder.textContent = '\u200B';
      range.insertNode(placeholder);
      range.insertNode(br);
      range.setStartAfter(placeholder);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function syncInputForElement(target) {
      const field = target.dataset.field;
      const recordIndex = Number(target.dataset.recordIndex);
      if (!field || Number.isNaN(recordIndex)) {
        return;
      }
      const recordElement = getRecordElement(recordIndex);
      if (!recordElement) {
        return;
      }
      const text = field === 'roleName'
        ? normalizeTextFromElement(target)
        : normalizeTextFromElement(getBodyElement(recordElement));
      postMessage({
        type: 'inputPatch',
        recordIndex,
        field,
        text,
      });
      if (field === 'body') {
        scheduleLayoutUpdate(recordIndex);
      }
    }

    function renderDocument(message) {
      if (!message || message.type !== 'initDocument') {
        return;
      }

      const doc = message.document || { records: [] };
      currentDocument = doc;
      const settings = message.settings || lastSettings || {};
      lastSettings = settings;

      const pageWidth = mmToPx(settings.pageWidthMm || 297);
      const pageHeight = mmToPx(settings.pageHeightMm || 210);
      const marginLeft = mmToPx(settings.marginLeftMm || 20);
      const marginRight = mmToPx(settings.marginRightMm || 20);
      const marginTop = mmToPx(settings.marginTopMm || 25);
      const marginBottom = mmToPx(settings.marginBottomMm || 25);
      const fontSize = (settings.fontSizePt || 10.5) / 72 * 96;
      const lineSpacing = settings.lineSpacing || 1.0;
      const lineAdvance = fontSize * lineSpacing;
      const roleLabelHeight = lineAdvance * 5.5;
      const recordGap = lineAdvance * 1.0;
      const contentWidth = pageWidth - marginLeft - marginRight;
      const contentHeight = pageHeight - marginTop - marginBottom;
      const bodyHeight = contentHeight - roleLabelHeight;
      const roleCharsPerColumn = Math.max(1, Math.floor(roleLabelHeight / lineAdvance));
      layoutState = {
        lineAdvance,
        contentHeight,
      };

      wrap.innerHTML = '';
      const page = document.createElement('div');
      page.className = 'page';
      page.style.width = `${pageWidth}px`;
      page.style.height = `${pageHeight}px`;
      page.style.setProperty('--font-size', `${fontSize}px`);
      page.style.setProperty('--line-advance', `${lineAdvance}px`);
      page.style.setProperty('--role-height', `${roleLabelHeight}px`);
      page.style.setProperty('--font-family', settings.fontFamily || '"游明朝", "Yu Mincho", "MS Mincho", serif');

      const content = document.createElement('div');
      content.className = 'content';
      content.style.top = `${marginTop}px`;
      content.style.left = `${marginLeft}px`;
      content.style.width = `${contentWidth}px`;
      content.style.height = `${contentHeight}px`;
      content.style.gap = `${recordGap}px`;

      for (let recordIndex = 0; recordIndex < (doc.records || []).length; recordIndex += 1) {
        const record = doc.records[recordIndex] || {};
        const bodyText = record.body || '';
        const bodyTokens = tokenizeText(bodyText);
        const roleTokens = tokenizeText(record.roleName || '');
        const recordWidth = lineAdvance;

        const recordContainer = document.createElement('div');
        recordContainer.className = 'record';
        recordContainer.dataset.recordIndex = `${recordIndex}`;
        recordContainer.style.height = `${contentHeight}px`;
        recordContainer.style.width = `${recordWidth}px`;

        const body = document.createElement('div');
        body.className = 'body';
        body.style.height = `${contentHeight}px`;
        body.style.width = `${recordWidth}px`;
        body.setAttribute('contenteditable', 'true');
        body.dataset.field = 'body';
        body.dataset.recordIndex = recordContainer.dataset.recordIndex;
        appendTokens(body, bodyTokens);

        const role = document.createElement('div');
        role.className = 'role';
        role.style.height = `${roleLabelHeight}px`;
        role.style.width = `${lineAdvance}px`;
        role.style.position = 'absolute';
        role.style.top = '0px';
        role.style.right = '0px';
        role.setAttribute('contenteditable', 'true');
        role.dataset.field = 'roleName';
        role.dataset.recordIndex = recordContainer.dataset.recordIndex;
        appendTokens(role, takeTokens(roleTokens, roleCharsPerColumn));

        recordContainer.appendChild(body);
        recordContainer.appendChild(role);
        content.appendChild(recordContainer);
      }

      page.appendChild(content);
      wrap.appendChild(page);

      requestAnimationFrame(() => {
        const recordElements = wrap.querySelectorAll('.record');
        recordElements.forEach((recordElement) => updateRecordWidth(recordElement));
      });

      if (pendingFocus) {
        focusRecord(pendingFocus.recordIndex, pendingFocus.field, pendingFocus.atStart);
        pendingFocus = null;
      }
    }

    function handleInput(event) {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      syncInputForElement(target);
    }

    function handleKeyDown(event) {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      const field = target.dataset.field;
      const recordIndex = Number(target.dataset.recordIndex);
      if (!field || Number.isNaN(recordIndex)) {
        return;
      }

      const recordElement = getRecordElement(recordIndex);
      if (!recordElement) {
        return;
      }
      const roleElement = getRoleElement(recordElement);
      const bodyElement = getBodyElement(recordElement);

      if (event.ctrlKey && event.key.startsWith('Arrow')) {
        let nextIndex = recordIndex;
        let nextField = field;
        if (field === 'body') {
          if (event.key === 'ArrowLeft') {
            nextIndex = recordIndex + 1;
            nextField = 'body';
          } else if (event.key === 'ArrowRight') {
            nextIndex = recordIndex - 1;
            nextField = 'body';
          } else if (event.key === 'ArrowUp') {
            nextIndex = recordIndex;
            nextField = 'roleName';
          } else if (event.key === 'ArrowDown') {
            nextIndex = recordIndex + 1;
            nextField = 'roleName';
          }
        } else {
          if (event.key === 'ArrowLeft') {
            nextIndex = recordIndex + 1;
            nextField = 'roleName';
          } else if (event.key === 'ArrowRight') {
            nextIndex = recordIndex - 1;
            nextField = 'roleName';
          } else if (event.key === 'ArrowUp') {
            nextIndex = recordIndex - 1;
            nextField = 'body';
          } else if (event.key === 'ArrowDown') {
            nextIndex = recordIndex;
            nextField = 'body';
          }
        }

        if (currentDocument && currentDocument.records) {
          if (nextIndex >= 0 && nextIndex < currentDocument.records.length) {
            event.preventDefault();
            focusRecord(nextIndex, nextField, true);
          } else {
            event.preventDefault();
            const atStart = event.key === 'ArrowRight' || event.key === 'ArrowUp';
            focusElement(target, atStart);
          }
        }
        return;
      }

      if (event.key === 'Tab') {
        event.preventDefault();
        if (event.shiftKey) {
          focusElement(roleElement);
        } else {
          focusElement(bodyElement);
        }
        return;
      }

      if (event.key === 'Enter' && field === 'roleName') {
        event.preventDefault();
        focusElement(bodyElement);
        return;
      }

      if (event.key === 'Enter' && field === 'body') {
        event.preventDefault();
        if (event.ctrlKey) {
          const nextIndex = recordIndex + 1;
          if (currentDocument && currentDocument.records && nextIndex < currentDocument.records.length) {
            focusRecord(nextIndex, 'roleName', true);
          } else {
            pendingFocus = { recordIndex: nextIndex, field: 'roleName', atStart: true };
            postMessage({ type: 'command', name: 'insertAfter', recordIndex });
          }
          return;
        }
        if (!event.shiftKey && isCurrentLineEmpty(target)) {
          const nextIndex = recordIndex + 1;
          if (currentDocument && currentDocument.records && nextIndex < currentDocument.records.length) {
            focusRecord(nextIndex, 'body', true);
          } else {
            pendingFocus = { recordIndex: nextIndex, field: 'body', atStart: true };
            postMessage({ type: 'command', name: 'insertAfter', recordIndex });
          }
          return;
        }
        insertLineBreakAtSelection();
        syncInputForElement(target);
        return;
      }

      if (event.key === 'Backspace') {
        const roleText = roleElement ? normalizeTextFromElement(roleElement).trim() : '';
        const bodyText = bodyElement ? normalizeTextFromElement(bodyElement).trim() : '';
        if (roleText.length === 0 && bodyText.length === 0) {
          event.preventDefault();
          const focusIndex = Math.max(0, recordIndex - 1);
          pendingFocus = { recordIndex: focusIndex, field: 'body', atStart: false };
          postMessage({ type: 'command', name: 'deleteRecord', recordIndex });
        }
      }
    }

    if (window.chrome && window.chrome.webview) {
      window.chrome.webview.postMessage({ type: 'documentReady' });
      wrap.addEventListener('input', handleInput, true);
      wrap.addEventListener('keydown', handleKeyDown, true);
      window.chrome.webview.addEventListener('message', (event) => {
        renderDocument(event.data);
      });
      status.textContent = 'ドキュメント受信待ちです';
    } else {
      status.textContent = 'WebView2 で開いてください';
    }
  </script>
</body>
</html>
